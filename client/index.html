<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Shadow</title>
  <link rel="stylesheet" href="styles/style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
</head>
<body>
  <div class="container">
    <h1>Project Shadow</h1>
    <p>Speak into your microphone and optionally share your webcam or screen to engage in a multimedia conversation.</p>
  </div>

  <div class="main-layout">
    <div class="chat-section">
      <div id="output"></div>
    </div>
    <div class="shared-state-section">
      <h3>Shared State</h3>
      <div id="sharedStateDisplay" class="shared-state-display">
        <p class="no-state">No shared state available yet</p>
      </div>
    </div>
  </div>

  <div class="input-container">
    <button id="micButton" disabled class="action-button">
      <span class="material-symbols-outlined">mic</span>
    </button>
    <button id="webcamButton" class="action-button">
      <span class="material-symbols-outlined">videocam</span>
    </button>
    <button id="screenButton" class="action-button">
      <span class="material-symbols-outlined">present_to_all</span>
    </button>
    <div class="text-input-container">
      <input type="text" id="textInput" placeholder="Type your message..." class="text-input">
      <button id="sendButton" class="action-button">
        <span class="material-symbols-outlined">send</span>
      </button>
      <button id="interruptButton" class="action-button" style="display: none;">
        <span class="material-symbols-outlined">cancel</span>
      </button>
    </div>
  </div>

  <div class="video-container">
    <video id="videoPreview" autoplay playsinline class="hidden"></video>
  </div>

  <!-- Load EventEmitter3 first -->
  <script src="https://cdn.jsdelivr.net/npm/eventemitter3@5.0.1/dist/eventemitter3.umd.min.js"></script>

  <script type="module">
    import { AudioRecorder } from './src/audio/audio-recorder.js';
    import { AudioStreamer } from './src/audio/audio-streamer.js';
    import { MediaHandler } from './src/media/media-handler.js';
    import { GeminiAPI } from './src/api/gemini-api.js';
    import { base64ToArrayBuffer } from './src/utils/utils.js';

    // Initialize components
    const output = document.getElementById('output');
    const sharedStateDisplay = document.getElementById('sharedStateDisplay');
    const audioRecorder = new AudioRecorder();
    const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
    const audioStreamer = new AudioStreamer(audioContext);
    const mediaHandler = new MediaHandler();
    const wsEndpoint = 'ws://localhost:8081';
    const api = new GeminiAPI(wsEndpoint);

    let isRecording = false;
    let hasShownSpeakingMessage = false;
    let currentTurn = 0;
    let lastAudioTurn = -1;

    // Initialize media handler
    mediaHandler.initialize(document.getElementById('videoPreview'));

    // Set up API handlers
    api.onReady = () => {
      document.getElementById('micButton').disabled = false;
    };

    api.onAudioData = async (audioData) => {
      try {
        if (!api.isSpeaking || lastAudioTurn !== currentTurn) {
          logMessage('Gemini: Speaking...');
          api.isSpeaking = true;
          lastAudioTurn = currentTurn;
          document.getElementById('interruptButton').style.display = 'inline-block';
        }
        const arrayBuffer = base64ToArrayBuffer(audioData);
        audioStreamer.addPCM16(new Uint8Array(arrayBuffer));
        audioStreamer.resume();
      } catch (error) {
        console.error('Error playing audio:', error);
      }
    };

    api.onTextContent = (text) => {
      if (text.trim()) {
        logMessage('Gemini: ' + text);
      }
    };

    api.onTurnComplete = () => {
      logMessage('Gemini: Finished speaking');
      api.isSpeaking = false;  // Reset speaking state
      audioStreamer.complete();
      document.getElementById('interruptButton').style.display = 'none';
    };

    // Add interruption handler
    api.onInterrupted = (data) => {
      logMessage('Gemini: Response interrupted');
      api.isSpeaking = false;
      audioStreamer.stop();  // Stop current playback and clear queue
      document.getElementById('interruptButton').style.display = 'none';
      
      // Show visual feedback for interruption
      const messageElement = document.createElement('p');
      messageElement.className = 'interrupted-message';
      messageElement.textContent = 'Response interrupted by user input';
      output.appendChild(messageElement);
      output.scrollTop = output.scrollHeight;
    };

    // Add function call and response handlers
    api.onFunctionCall = (data) => {
      logMessage('Function: ' + data.name);
      logMessage('Parameters: ' + JSON.stringify(data.args, null, 2));
    };

    api.onFunctionResponse = (data) => {
      logMessage('API Response: ' + JSON.stringify(data, null, 2));
      
      // Debug: Log the data structure
      console.log('Function response data:', data);
      console.log('Data keys:', Object.keys(data));
      
      // Update shared state display when ADK tools are used
      // Check for ADK tools in different possible data structures
      const toolName = data.tool || data.name || (data.data && data.data.tool) || (data.data && data.data.name);
      
      if (toolName && (toolName === 'timestamp_qa_pair' || toolName === 'signal_state_agent' || toolName === 'detect_user_response')) {
        console.log('ADK tool detected:', toolName);
        updateSharedStateDisplay(data);
      } else if (toolName) {
        console.log('Non-ADK tool detected:', toolName);
        // Show any function call for debugging
        updateSharedStateDisplay({...data, tool: toolName});
      } else {
        console.log('No tool detected. Full data:', data);
      }
    };

    // Handle StateAgent updates
    api.onStateAgentUpdate = (data) => {
      console.log('üéØ StateAgent update received:', data);
      console.log('üìä StateAgent data structure:', JSON.stringify(data, null, 2));
      
      if (data.update_type === 'qa_pair_created') {
        updateSharedStateDisplay({
          tool: 'qa_pair_created',
          data: {
            question: data.data.question,
            answer: data.data.answer,
            timestamp: data.data.timestamp,
            is_enriched: data.data.is_enriched,
            message: data.data.message
          }
        });
      } else if (data.update_type === 'qa_pair_enriched') {
        updateSharedStateDisplay({
          tool: 'qa_pair_enriched',
          data: {
            question: data.data.question,
            answer: data.data.answer,
            timestamp: data.data.timestamp,
            behavioral_insights: data.data.behavioral_insights,
            confidence: data.data.confidence,
            features_count: data.data.features_count,
            is_enriched: data.data.is_enriched,
            message: data.data.message
          }
        });
      } else {
        // Fallback for other update types
        updateSharedStateDisplay({
          tool: 'state_agent_update',
          data: {
            update_type: data.update_type,
            description: data.data.description || data.data.message,
            confidence: data.data.confidence,
            features_count: data.data.features_count,
            timestamp: data.data.timestamp,
            message: `StateAgent: ${data.data.message || data.data.description}`
          }
        });
      }
      
      console.log('‚úÖ StateAgent update displayed in shared state panel');
    };

    // UI Event Handlers
    async function startRecording() {
      try {
        // If model is speaking, treat this as an interruption
        if (api.isSpeaking) {
          audioStreamer.stop();
          api.isSpeaking = false;
        }

        await audioContext.resume();
        await audioRecorder.start();
        hasShownSpeakingMessage = false;
        currentTurn++;
        
        audioRecorder.on('data', (base64Data) => {
          if (!hasShownSpeakingMessage) {
            logMessage('You: Speaking...');
            hasShownSpeakingMessage = true;
          }
          api.sendAudioChunk(base64Data);
        });

        isRecording = true;
        document.getElementById('micButton').innerHTML = 
          '<span class="material-symbols-outlined">stop</span>';
      } catch (error) {
        console.error('Error starting recording:', error);
        logMessage('Error: ' + error.message);
      }
    }

    function stopRecording() {
      audioRecorder.stop();
      isRecording = false;
      hasShownSpeakingMessage = false;
      document.getElementById('micButton').innerHTML = 
        '<span class="material-symbols-outlined">mic</span>';
      logMessage('You: Recording stopped.');
      
      // Stop video streams
      mediaHandler.stopAll();
      document.getElementById('webcamButton').innerHTML = 
        '<span class="material-symbols-outlined">videocam</span>';
      document.getElementById('screenButton').innerHTML = 
        '<span class="material-symbols-outlined">present_to_all</span>';
      
      api.sendEndMessage();
      api.isSpeaking = false;
    }

    function logMessage(message) {
      const messageElement = document.createElement('p');
      
      // Add specific styling based on message content
      if (message.startsWith('Function:')) {
        messageElement.className = 'function-name';
      } else if (message.startsWith('Parameters:')) {
        messageElement.className = 'function-params';
      } else if (message.startsWith('API Response:')) {
        messageElement.className = 'api-response';
      } else if (message.startsWith('Gemini:')) {
        messageElement.className = 'gemini-message';
      } else if (message.startsWith('You:')) {
        messageElement.className = 'user-message';
      }
      
      messageElement.textContent = message;
      output.appendChild(messageElement);
      output.scrollTop = output.scrollHeight;
    }

    function updateSharedStateDisplay(data) {
      const timestamp = new Date().toLocaleTimeString();
      const stateElement = document.createElement('div');
      stateElement.className = 'state-update';
      
      // Extract tool name from different possible data structures
      const toolName = data.tool || data.name || (data.data && data.data.tool) || (data.data && data.data.name);
      
      let content = `<div class="state-header">
        <span class="state-tool">${toolName}</span>
        <span class="state-timestamp">${timestamp}</span>
      </div>`;
      
      // Extract data from different possible structures
      const responseData = data.data || data;
      
      if (toolName === 'timestamp_qa_pair') {
        content += `<div class="state-content">
          <strong>Question:</strong> ${responseData.question || 'N/A'}<br>
          <strong>Answer:</strong> ${responseData.answer || 'N/A'}<br>
          <strong>Timestamp:</strong> ${responseData.timestamp || 'N/A'}<br>
          <strong>Message:</strong> ${responseData.message || 'N/A'}
        </div>`;
      } else if (toolName === 'qa_pair_created') {
        content += `<div class="state-content">
          <strong>üìù Q&A Pair Created:</strong><br>
          <strong>Question:</strong> ${responseData.question || 'N/A'}<br>
          <strong>Answer:</strong> ${responseData.answer || 'N/A'}<br>
          <strong>Status:</strong> ‚è≥ Behavioral analysis in progress...<br>
          <strong>Timestamp:</strong> ${responseData.timestamp || 'N/A'}
        </div>`;
      } else if (toolName === 'qa_pair_enriched') {
        content += `<div class="state-content">
          <strong>üéØ Q&A Pair Enriched:</strong><br>
          <strong>Question:</strong> ${responseData.question || 'N/A'}<br>
          <strong>Answer:</strong> ${responseData.answer || 'N/A'}<br>
          <strong>üß† Behavioral Insights:</strong> ${responseData.behavioral_insights || 'N/A'}<br>
          <strong>üìä Confidence:</strong> ${responseData.confidence || 'N/A'}<br>
          <strong>üîç Features Count:</strong> ${responseData.features_count || 'N/A'}<br>
          <strong>Timestamp:</strong> ${responseData.timestamp || 'N/A'}
        </div>`;
      } else if (toolName === 'state_agent_update') {
        content += `<div class="state-content">
          <strong>Update Type:</strong> ${responseData.update_type || 'N/A'}<br>
          <strong>Description:</strong> ${responseData.description || 'N/A'}<br>
          <strong>Confidence:</strong> ${responseData.confidence || 'N/A'}<br>
          <strong>Features Count:</strong> ${responseData.features_count || 'N/A'}<br>
          <strong>Timestamp:</strong> ${responseData.timestamp || 'N/A'}
        </div>`;
      } else if (toolName === 'signal_state_agent') {
        content += `<div class="state-content">
          <strong>Signal Type:</strong> ${responseData.signal_type || 'N/A'}<br>
          <strong>Message:</strong> ${responseData.message || 'N/A'}
        </div>`;
      } else if (toolName === 'detect_user_response') {
        content += `<div class="state-content">
          <strong>Response Type:</strong> ${responseData.response_type || 'N/A'}<br>
          <strong>User Response:</strong> ${responseData.user_response || 'N/A'}<br>
          <strong>Message:</strong> ${responseData.message || 'N/A'}
        </div>`;
      } else {
        // Generic display for any ADK tool
        content += `<div class="state-content">
          <strong>Raw Data:</strong> ${JSON.stringify(responseData, null, 2)}
        </div>`;
      }
      
      stateElement.innerHTML = content;
      
      // Remove the "no state" message if it exists
      const noStateElement = sharedStateDisplay.querySelector('.no-state');
      if (noStateElement) {
        noStateElement.remove();
      }
      
      // Add the new state update at the top
      sharedStateDisplay.insertBefore(stateElement, sharedStateDisplay.firstChild);
      
      // Keep only the last 10 state updates
      const stateUpdates = sharedStateDisplay.querySelectorAll('.state-update');
      if (stateUpdates.length > 10) {
        stateUpdates[stateUpdates.length - 1].remove();
      }
    }

    // Add function to send text message
    function sendTextMessage() {
      const textInput = document.getElementById('textInput');
      const text = textInput.value.trim();
      if (!text) return;

      // Clear input
      textInput.value = '';

      // Log user message
      logMessage('You: ' + text);

      // Send text message
      api.sendTextMessage(text);
    }

    // Set up button click handlers
    document.getElementById('micButton').onclick = () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    };

    // Add send button handler
    document.getElementById('sendButton').onclick = sendTextMessage;

    // Add keypress handler for text input
    document.getElementById('textInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendTextMessage();
      }
    });

    document.getElementById('webcamButton').onclick = async () => {
      if (mediaHandler.isWebcamActive) {
        mediaHandler.stopAll();
        document.getElementById('webcamButton').innerHTML = 
          '<span class="material-symbols-outlined">videocam</span>';
      } else {
        const success = await mediaHandler.startWebcam();
        if (success) {
          document.getElementById('webcamButton').innerHTML = 
            '<span class="material-symbols-outlined">videocam_off</span>';
          mediaHandler.startFrameCapture((base64Image) => {
            api.sendImage(base64Image);
          });
        }
      }
    };

    document.getElementById('screenButton').onclick = async () => {
      if (mediaHandler.isScreenActive) {
        mediaHandler.stopAll();
        document.getElementById('screenButton').innerHTML = 
          '<span class="material-symbols-outlined">present_to_all</span>';
      } else {
        const success = await mediaHandler.startScreenShare();
        if (success) {
          document.getElementById('screenButton').innerHTML = 
            '<span class="material-symbols-outlined">cancel_presentation</span>';
          mediaHandler.startFrameCapture((base64Image) => {
            api.sendImage(base64Image);
          });
        }
      }
    };

    // Add CSS for interrupted message and shared state
    const style = document.createElement('style');
    style.textContent = `
      .interrupted-message {
        color: #ff6b6b;
        font-style: italic;
        margin: 4px 0;
        padding: 4px 8px;
        border-left: 3px solid #ff6b6b;
        background-color: rgba(255, 107, 107, 0.1);
      }
      
      .main-layout {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }
      
      .chat-section {
        flex: 2;
      }
      
      .shared-state-section {
        flex: 1;
        min-width: 300px;
      }
      
      .shared-state-section h3 {
        margin: 0 0 10px 0;
        color: #333;
        font-size: 16px;
        border-bottom: 2px solid #007bff;
        padding-bottom: 5px;
      }
      
      .shared-state-display {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        max-height: 400px;
        overflow-y: auto;
      }
      
      .no-state {
        color: #6c757d;
        font-style: italic;
        text-align: center;
        margin: 20px 0;
      }
      
      .state-update {
        background-color: white;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      
      .state-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding-bottom: 5px;
        border-bottom: 1px solid #e9ecef;
      }
      
      .state-tool {
        background-color: #007bff;
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
      }
      
      .state-timestamp {
        color: #6c757d;
        font-size: 11px;
      }
      
      .state-content {
        font-size: 13px;
        line-height: 1.4;
      }
      
      .state-content strong {
        color: #495057;
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>